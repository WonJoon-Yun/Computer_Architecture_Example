
============================================================
Assembling: program/test1.asm
Output: results/test1.obj
Debug log: /Users/wonjoonyun/Library/CloudStorage/OneDrive-TheUniversityofTexasatAustin/01_lecture/Computer_Architecture_Example/1_Opcode/debug/test1.asm.debug
============================================================

=== PASS 1: Building Symbol Table ===
  [Line   2] Tokenize: '        .orig x3000'
    -> Tokens: ['.orig', 'x3000']
    -> Parse constant (hex): x3000 -> 12288 (0x3000)
  [Line   2] .ORIG: Starting address = 0x3000 (12288)
  [Line   3] Tokenize: '        lea r0, ten       ;this instruction will be loaded into memory location x3000'
    -> Tokens: ['lea', 'r0', 'ten']
    -> Comment: 'this instruction will be loaded into memory location x3000'
  [Line   3] Address 0x3000: lea (size: 2 bytes)
  [Line   4] Tokenize: '        ldw r1, r0, #0'
    -> Tokens: ['ldw', 'r1', 'r0', '#0']
  [Line   4] Address 0x3002: ldw (size: 2 bytes)
  [Line   5] Tokenize: 'start   add r1, r1, #-1'
    -> Tokens: ['start', 'add', 'r1', 'r1', '#-1']
  [Line   5] Label 'start' -> 0x3004 (12292)
  [Line   5] Address 0x3004: add (size: 2 bytes)
  [Line   6] Tokenize: '        brz done'
    -> Tokens: ['brz', 'done']
  [Line   6] Address 0x3006: brz (size: 2 bytes)
  [Line   7] Tokenize: '        br start'
    -> Tokens: ['br', 'start']
  [Line   7] Address 0x3008: br (size: 2 bytes)
  [Line   9] Tokenize: 'done    trap x25          ;the last executable instruction'
    -> Tokens: ['done', 'trap', 'x25']
    -> Comment: 'the last executable instruction'
  [Line   9] Label 'done' -> 0x300A (12298)
  [Line   9] Address 0x300A: trap (size: 2 bytes)
  [Line  10] Tokenize: 'ten     .fill x000a       ;this is 10 in 2's comp, hexadecimal'
    -> Tokens: ['ten', '.fill', 'x000a']
    -> Comment: 'this is 10 in 2's comp, hexadecimal'
  [Line  10] Label 'ten' -> 0x300C (12300)
  [Line  10] Address 0x300C: .fill (size: 2 bytes)
  [Line  11] Tokenize: '        .end              ;the pseudo-op, delimiting the source program'
    -> Tokens: ['.end']
    -> Comment: 'the pseudo-op, delimiting the source program'
  [Line  11] .END: End of assembly

Symbol Table (3 symbols):
  done                 -> 0x300A (12298)
  start                -> 0x3004 (12292)
  ten                  -> 0x300C (12300)
Final address: 0x300E (12302)
==================================================

=== PASS 2: Code Generation ===
  [Line   2] Tokenize: '        .orig x3000'
    -> Tokens: ['.orig', 'x3000']
    -> Parse constant (hex): x3000 -> 12288 (0x3000)
  [Line   2] Write .ORIG: 0x3000
  [Line   3] Tokenize: '        lea r0, ten       ;this instruction will be loaded into memory location x3000'
    -> Tokens: ['lea', 'r0', 'ten']
    -> Comment: 'this instruction will be loaded into memory location x3000'
  [Line   3] Address 0x3000: lea ['r0', 'ten']
    -> Parse register: r0 -> R0
    -> LEA target: Symbol 'ten' -> 0x300C
    -> PC offset: target=0x300C, current=0x3000, offset=5 (9 bits)
    -> Masked offset: 0x0005 (binary: 000000101)
    -> LEA encoding (Load Effective Address):
       Format: [1110][DR][PCoffset9]
       Opcode: 1110 (0xE) = 0xE000
       Destination register: R0 = 0x0000
       PC offset: 5 (9 bits) = 0x0005
       Target address: 0x300C
       Write register: R0
       Operation: R0 = PC + 5 = 0x300C
       Encoding: 0xE000 | 0x0000 | 0x0005 = 0xE005
       Machine code: 0xE005 (1110000000000101)
    -> Write: 0xE005 (binary: 1110000000000101)
  [Line   4] Tokenize: '        ldw r1, r0, #0'
    -> Tokens: ['ldw', 'r1', 'r0', '#0']
  [Line   4] Address 0x3002: ldw ['r1', 'r0', '#0']
    -> Parse register: r1 -> R1
    -> Parse register: r0 -> R0
    -> Parse constant (decimal): #0 -> 0 (0x0000)
    -> LDW encoding (Load Word):
       Format: [0110][DR][Base][offset6]
       Opcode: 0110 (0x6) = 0x6000
       Destination register: R1 = 0x0200
       Base register: R0 = 0x0000
       Offset: 0 (6 bits, signed) = 0x00
       Read register: R0 (base address)
       Write register: R1
       Operation: R1 = Mem[R0 + 0] (word)
       Encoding: 0x6000 | 0x0200 | 0x0000 | 0x00 = 0x6200
       Machine code: 0x6200 (0110001000000000)
    -> Write: 0x6200 (binary: 0110001000000000)
  [Line   5] Tokenize: 'start   add r1, r1, #-1'
    -> Tokens: ['start', 'add', 'r1', 'r1', '#-1']
  [Line   5] Address 0x3004: add ['r1', 'r1', '#-1']
    -> Parse register: r1 -> R1
    -> Parse register: r1 -> R1
    -> Parse constant (decimal): #-1 -> -1 (0x-001)
    -> ADD encoding (immediate mode):
       Format: [0001][DR][SR1][1][imm5]
       Opcode: 0001 (0x1) = 0x1000
       Destination register: R1 = 0x0200
       Source register 1: R1 = 0x0040
       Mode bit: 1 (immediate mode) = 0x0020
       Immediate value: 31 (5 bits, signed) = 0x1F
       Read register: R1
       Write register: R1
       Operation: R1 = R1 + 31
       Encoding: 0x1000 | 0x0200 | 0x0040 | 0x0020 | 0x1F = 0x127F
       Machine code: 0x127F (0001001001111111)
    -> Write: 0x127F (binary: 0001001001111111)
  [Line   6] Tokenize: '        brz done'
    -> Tokens: ['brz', 'done']
  [Line   6] Address 0x3006: brz ['done']
    -> BR target: Symbol 'done' -> 0x300A
    -> PC offset: target=0x300A, current=0x3006, offset=1 (9 bits)
    -> Masked offset: 0x0001 (binary: 000000001)
    -> BR encoding:
       Condition flags: N=0, Z=1, P=0 (Z)
       Target address: 0x300A
       Operation: if (condition) PC = PC + 1 = 0x300A
       Machine code: 0x0401 (0000010000000001)
    -> Write: 0x0401 (binary: 0000010000000001)
  [Line   7] Tokenize: '        br start'
    -> Tokens: ['br', 'start']
  [Line   7] Address 0x3008: br ['start']
    -> BR target: Symbol 'start' -> 0x3004
    -> PC offset: target=0x3004, current=0x3008, offset=-3 (9 bits)
    -> Masked offset: 0x01FD (binary: 111111101)
    -> BR encoding:
       Condition flags: N=1, Z=1, P=1 (NZP)
       Target address: 0x3004
       Operation: if (condition) PC = PC + 509 = 0x3004
       Machine code: 0x0FFD (0000111111111101)
    -> Write: 0x0FFD (binary: 0000111111111101)
  [Line   9] Tokenize: 'done    trap x25          ;the last executable instruction'
    -> Tokens: ['done', 'trap', 'x25']
    -> Comment: 'the last executable instruction'
  [Line   9] Address 0x300A: trap ['x25']
    -> Parse constant (hex): x25 -> 37 (0x0025)
    -> TRAP encoding:
       TRAP instruction format: [1111][trapvect8]
       Opcode: 1111 (0xF) = 0xF000
       Trap vector: x25 = 0x25 = 0x0025
       Encoding: 0xF000 | 0x0025 = 0xF025
       Machine code: 0xF025 (1111000000100101)
    -> Write: 0xF025 (binary: 1111000000100101)
  [Line  10] Tokenize: 'ten     .fill x000a       ;this is 10 in 2's comp, hexadecimal'
    -> Tokens: ['ten', '.fill', 'x000a']
    -> Comment: 'this is 10 in 2's comp, hexadecimal'
  [Line  10] Address 0x300C: .fill ['x000a']
    -> Parse constant (hex): x000a -> 10 (0x000A)
    -> .FILL pseudo-op encoding:
       Pseudo-op: .FILL (not a real instruction)
       Value: 10 (0x000A)
       Operation: Store 16-bit value at current address
       Output: 0x000A (0000000000001010)
    -> Write: 0x000A (binary: 0000000000001010)
  [Line  11] Tokenize: '        .end              ;the pseudo-op, delimiting the source program'
    -> Tokens: ['.end']
    -> Comment: 'the pseudo-op, delimiting the source program'
  [Line  11] .END: Stopping assembly

============================================================
Assembly complete: program/test1.asm -> results/test1.obj
Debug log saved to: /Users/wonjoonyun/Library/CloudStorage/OneDrive-TheUniversityofTexasatAustin/01_lecture/Computer_Architecture_Example/1_Opcode/debug/test1.asm.debug
============================================================

