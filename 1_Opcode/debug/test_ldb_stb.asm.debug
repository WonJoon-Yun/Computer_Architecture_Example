
============================================================
Assembling: program/test_ldb_stb.asm
Output: results/test_ldb_stb.obj
Debug log: /Users/wonjoonyun/Library/CloudStorage/OneDrive-TheUniversityofTexasatAustin/01_lecture/Computer_Architecture_Example/1_Opcode/debug/test_ldb_stb.asm.debug
============================================================

=== PASS 1: Building Symbol Table ===
  [Line   5] Tokenize: '    .orig x3000'
    -> Tokens: ['.orig', 'x3000']
    -> Parse constant (hex): x3000 -> 12288 (0x3000)
  [Line   5] .ORIG: Starting address = 0x3000 (12288)
  [Line   6] Tokenize: '    lea r0,location'
    -> Tokens: ['lea', 'r0', 'location']
  [Line   6] Address 0x3000: lea (size: 2 bytes)
  [Line   7] Tokenize: '	ldb r1,r0,#0'
    -> Tokens: ['ldb', 'r1', 'r0', '#0']
  [Line   7] Address 0x3002: ldb (size: 2 bytes)
  [Line   8] Tokenize: '	ldb r2,r0,#1'
    -> Tokens: ['ldb', 'r2', 'r0', '#1']
  [Line   8] Address 0x3004: ldb (size: 2 bytes)
  [Line   9] Tokenize: '    stb r1,r0,#1'
    -> Tokens: ['stb', 'r1', 'r0', '#1']
  [Line   9] Address 0x3006: stb (size: 2 bytes)
  [Line  10] Tokenize: '	stb r2,r0,#0'
    -> Tokens: ['stb', 'r2', 'r0', '#0']
  [Line  10] Address 0x3008: stb (size: 2 bytes)
  [Line  11] Tokenize: '	halt'
    -> Tokens: ['halt']
  [Line  11] Address 0x300A: halt (size: 2 bytes)
  [Line  13] Tokenize: 'a         .fill x7788'
    -> Tokens: ['a', '.fill', 'x7788']
  [Line  13] Label 'a' -> 0x300C (12300)
  [Line  13] Address 0x300C: .fill (size: 2 bytes)
  [Line  14] Tokenize: 'location  .fill x1234'
    -> Tokens: ['location', '.fill', 'x1234']
  [Line  14] Label 'location' -> 0x300E (12302)
  [Line  14] Address 0x300E: .fill (size: 2 bytes)
  [Line  15] Tokenize: 'b         .fill x5566'
    -> Tokens: ['b', '.fill', 'x5566']
  [Line  15] Label 'b' -> 0x3010 (12304)
  [Line  15] Address 0x3010: .fill (size: 2 bytes)
  [Line  17] Tokenize: '    .end'
    -> Tokens: ['.end']
  [Line  17] .END: End of assembly

Symbol Table (3 symbols):
  a                    -> 0x300C (12300)
  b                    -> 0x3010 (12304)
  location             -> 0x300E (12302)
Final address: 0x3012 (12306)
==================================================

=== PASS 2: Code Generation ===
  [Line   5] Tokenize: '    .orig x3000'
    -> Tokens: ['.orig', 'x3000']
    -> Parse constant (hex): x3000 -> 12288 (0x3000)
  [Line   5] Write .ORIG: 0x3000
  [Line   6] Tokenize: '    lea r0,location'
    -> Tokens: ['lea', 'r0', 'location']
  [Line   6] Address 0x3000: lea ['r0', 'location']
    -> Parse register: r0 -> R0
    -> LEA target: Symbol 'location' -> 0x300E
    -> PC offset: target=0x300E, current=0x3000, offset=6 (9 bits)
    -> Masked offset: 0x0006 (binary: 000000110)
    -> LEA encoding (Load Effective Address):
       Format: [1110][DR][PCoffset9]
       Opcode: 1110 (0xE) = 0xE000
       Destination register: R0 = 0x0000
       PC offset: 6 (9 bits) = 0x0006
       Target address: 0x300E
       Write register: R0
       Operation: R0 = PC + 6 = 0x300E
       Encoding: 0xE000 | 0x0000 | 0x0006 = 0xE006
       Machine code: 0xE006 (1110000000000110)
    -> Write: 0xE006 (binary: 1110000000000110)
  [Line   7] Tokenize: '	ldb r1,r0,#0'
    -> Tokens: ['ldb', 'r1', 'r0', '#0']
  [Line   7] Address 0x3002: ldb ['r1', 'r0', '#0']
    -> Parse register: r1 -> R1
    -> Parse register: r0 -> R0
    -> Parse constant (decimal): #0 -> 0 (0x0000)
    -> LDB encoding (Load Byte):
       Format: [0010][DR][Base][offset6]
       Opcode: 0010 (0x2) = 0x2000
       Destination register: R1 = 0x0200
       Base register: R0 = 0x0000
       Offset: 0 (6 bits, signed) = 0x00
       Read register: R0 (base address)
       Write register: R1
       Operation: R1 = Mem[R0 + 0] (byte, sign-extended)
       Encoding: 0x2000 | 0x0200 | 0x0000 | 0x00 = 0x2200
       Machine code: 0x2200 (0010001000000000)
    -> Write: 0x2200 (binary: 0010001000000000)
  [Line   8] Tokenize: '	ldb r2,r0,#1'
    -> Tokens: ['ldb', 'r2', 'r0', '#1']
  [Line   8] Address 0x3004: ldb ['r2', 'r0', '#1']
    -> Parse register: r2 -> R2
    -> Parse register: r0 -> R0
    -> Parse constant (decimal): #1 -> 1 (0x0001)
    -> LDB encoding (Load Byte):
       Format: [0010][DR][Base][offset6]
       Opcode: 0010 (0x2) = 0x2000
       Destination register: R2 = 0x0400
       Base register: R0 = 0x0000
       Offset: 1 (6 bits, signed) = 0x01
       Read register: R0 (base address)
       Write register: R2
       Operation: R2 = Mem[R0 + 1] (byte, sign-extended)
       Encoding: 0x2000 | 0x0400 | 0x0000 | 0x01 = 0x2401
       Machine code: 0x2401 (0010010000000001)
    -> Write: 0x2401 (binary: 0010010000000001)
  [Line   9] Tokenize: '    stb r1,r0,#1'
    -> Tokens: ['stb', 'r1', 'r0', '#1']
  [Line   9] Address 0x3006: stb ['r1', 'r0', '#1']
    -> Parse register: r1 -> R1
    -> Parse register: r0 -> R0
    -> Parse constant (decimal): #1 -> 1 (0x0001)
    -> STB encoding (Store Byte):
       Format: [0011][SR][Base][offset6]
       Opcode: 0011 (0x3) = 0x3000
       Source register: R1 = 0x0200
       Base register: R0 = 0x0000
       Offset: 1 (6 bits, signed) = 0x01
       Read registers: R1 (data), R0 (base address)
       Write memory: Mem[R0 + 1] (byte)
       Operation: Mem[R0 + 1] = R1[7:0] (low byte)
       Encoding: 0x3000 | 0x0200 | 0x0000 | 0x01 = 0x3201
       Machine code: 0x3201 (0011001000000001)
    -> Write: 0x3201 (binary: 0011001000000001)
  [Line  10] Tokenize: '	stb r2,r0,#0'
    -> Tokens: ['stb', 'r2', 'r0', '#0']
  [Line  10] Address 0x3008: stb ['r2', 'r0', '#0']
    -> Parse register: r2 -> R2
    -> Parse register: r0 -> R0
    -> Parse constant (decimal): #0 -> 0 (0x0000)
    -> STB encoding (Store Byte):
       Format: [0011][SR][Base][offset6]
       Opcode: 0011 (0x3) = 0x3000
       Source register: R2 = 0x0400
       Base register: R0 = 0x0000
       Offset: 0 (6 bits, signed) = 0x00
       Read registers: R2 (data), R0 (base address)
       Write memory: Mem[R0 + 0] (byte)
       Operation: Mem[R0 + 0] = R2[7:0] (low byte)
       Encoding: 0x3000 | 0x0400 | 0x0000 | 0x00 = 0x3400
       Machine code: 0x3400 (0011010000000000)
    -> Write: 0x3400 (binary: 0011010000000000)
  [Line  11] Tokenize: '	halt'
    -> Tokens: ['halt']
  [Line  11] Address 0x300A: halt []
    -> HALT encoding (TRAP x25):
       TRAP instruction format: [1111][trapvect8]
       Opcode: 1111 (0xF) = 0xF000
       Trap vector: x25 (0x25) = 0x0025
       Encoding: 0xF000 | 0x0025 = 0xF025
       Operation: System call to halt the program
       Effect: Program execution stops, no return value
       Machine code: 0xF025 (1111000000100101)
    -> Write: 0xF025 (binary: 1111000000100101)
  [Line  13] Tokenize: 'a         .fill x7788'
    -> Tokens: ['a', '.fill', 'x7788']
  [Line  13] Address 0x300C: .fill ['x7788']
    -> Parse constant (hex): x7788 -> 30600 (0x7788)
    -> .FILL pseudo-op encoding:
       Pseudo-op: .FILL (not a real instruction)
       Value: 30600 (0x7788)
       Operation: Store 16-bit value at current address
       Output: 0x7788 (0111011110001000)
    -> Write: 0x7788 (binary: 0111011110001000)
  [Line  14] Tokenize: 'location  .fill x1234'
    -> Tokens: ['location', '.fill', 'x1234']
  [Line  14] Address 0x300E: .fill ['x1234']
    -> Parse constant (hex): x1234 -> 4660 (0x1234)
    -> .FILL pseudo-op encoding:
       Pseudo-op: .FILL (not a real instruction)
       Value: 4660 (0x1234)
       Operation: Store 16-bit value at current address
       Output: 0x1234 (0001001000110100)
    -> Write: 0x1234 (binary: 0001001000110100)
  [Line  15] Tokenize: 'b         .fill x5566'
    -> Tokens: ['b', '.fill', 'x5566']
  [Line  15] Address 0x3010: .fill ['x5566']
    -> Parse constant (hex): x5566 -> 21862 (0x5566)
    -> .FILL pseudo-op encoding:
       Pseudo-op: .FILL (not a real instruction)
       Value: 21862 (0x5566)
       Operation: Store 16-bit value at current address
       Output: 0x5566 (0101010101100110)
    -> Write: 0x5566 (binary: 0101010101100110)
  [Line  17] Tokenize: '    .end'
    -> Tokens: ['.end']
  [Line  17] .END: Stopping assembly

============================================================
Assembly complete: program/test_ldb_stb.asm -> results/test_ldb_stb.obj
Debug log saved to: /Users/wonjoonyun/Library/CloudStorage/OneDrive-TheUniversityofTexasatAustin/01_lecture/Computer_Architecture_Example/1_Opcode/debug/test_ldb_stb.asm.debug
============================================================

