
============================================================
Assembling: program/test_shf.asm
Output: results/test_shf.obj
Debug log: /Users/wonjoonyun/Library/CloudStorage/OneDrive-TheUniversityofTexasatAustin/01_lecture/Computer_Architecture_Example/1_Opcode/debug/test_shf.asm.debug
============================================================

=== PASS 1: Building Symbol Table ===
  [Line   1] Tokenize: '     .orig x3000'
    -> Tokens: ['.orig', 'x3000']
    -> Parse constant (hex): x3000 -> 12288 (0x3000)
  [Line   1] .ORIG: Starting address = 0x3000 (12288)
  [Line   2] Tokenize: '     lea   r0, a'
    -> Tokens: ['lea', 'r0', 'a']
  [Line   2] Address 0x3000: lea (size: 2 bytes)
  [Line   3] Tokenize: '     ldw   r0,r0,#0'
    -> Tokens: ['ldw', 'r0', 'r0', '#0']
  [Line   3] Address 0x3002: ldw (size: 2 bytes)
  [Line   4] Tokenize: '     lshf  r0,r0,#3'
    -> Tokens: ['lshf', 'r0', 'r0', '#3']
  [Line   4] Address 0x3004: lshf (size: 2 bytes)
  [Line   5] Tokenize: '     rshfl r0,r0,#3'
    -> Tokens: ['rshfl', 'r0', 'r0', '#3']
  [Line   5] Address 0x3006: rshfl (size: 2 bytes)
  [Line   6] Tokenize: '     lshf  r0,r0,#3'
    -> Tokens: ['lshf', 'r0', 'r0', '#3']
  [Line   6] Address 0x3008: lshf (size: 2 bytes)
  [Line   7] Tokenize: '     rshfa r0,r0,#3'
    -> Tokens: ['rshfa', 'r0', 'r0', '#3']
  [Line   7] Address 0x300A: rshfa (size: 2 bytes)
  [Line   8] Tokenize: '     halt'
    -> Tokens: ['halt']
  [Line   8] Address 0x300C: halt (size: 2 bytes)
  [Line  10] Tokenize: 'a   .fill x1234'
    -> Tokens: ['a', '.fill', 'x1234']
  [Line  10] Label 'a' -> 0x300E (12302)
  [Line  10] Address 0x300E: .fill (size: 2 bytes)
  [Line  12] Tokenize: '    .end'
    -> Tokens: ['.end']
  [Line  12] .END: End of assembly

Symbol Table (1 symbols):
  a                    -> 0x300E (12302)
Final address: 0x3010 (12304)
==================================================

=== PASS 2: Code Generation ===
  [Line   1] Tokenize: '     .orig x3000'
    -> Tokens: ['.orig', 'x3000']
    -> Parse constant (hex): x3000 -> 12288 (0x3000)
  [Line   1] Write .ORIG: 0x3000
  [Line   2] Tokenize: '     lea   r0, a'
    -> Tokens: ['lea', 'r0', 'a']
  [Line   2] Address 0x3000: lea ['r0', 'a']
    -> Parse register: r0 -> R0
    -> LEA target: Symbol 'a' -> 0x300E
    -> PC offset: target=0x300E, current=0x3000, offset=6 (9 bits)
    -> Masked offset: 0x0006 (binary: 000000110)
    -> LEA encoding: dr=R0, offset=6 -> 0xE006
    -> Write: 0xE006 (binary: 1110000000000110)
  [Line   3] Tokenize: '     ldw   r0,r0,#0'
    -> Tokens: ['ldw', 'r0', 'r0', '#0']
  [Line   3] Address 0x3002: ldw ['r0', 'r0', '#0']
    -> Parse register: r0 -> R0
    -> Parse register: r0 -> R0
    -> Parse constant (decimal): #0 -> 0 (0x0000)
    -> Write: 0x6000 (binary: 0110000000000000)
  [Line   4] Tokenize: '     lshf  r0,r0,#3'
    -> Tokens: ['lshf', 'r0', 'r0', '#3']
  [Line   4] Address 0x3004: lshf ['r0', 'r0', '#3']
    -> Parse register: r0 -> R0
    -> Parse register: r0 -> R0
    -> Parse constant (decimal): #3 -> 3 (0x0003)
    -> Shift encoding: op=1101, dr=R0, sr=R0, mode=00, amount=3 -> 0xD003
    -> Write: 0xD003 (binary: 1101000000000011)
  [Line   5] Tokenize: '     rshfl r0,r0,#3'
    -> Tokens: ['rshfl', 'r0', 'r0', '#3']
  [Line   5] Address 0x3006: rshfl ['r0', 'r0', '#3']
    -> Parse register: r0 -> R0
    -> Parse register: r0 -> R0
    -> Parse constant (decimal): #3 -> 3 (0x0003)
    -> Shift encoding: op=1101, dr=R0, sr=R0, mode=01, amount=3 -> 0xD013
    -> Write: 0xD013 (binary: 1101000000010011)
  [Line   6] Tokenize: '     lshf  r0,r0,#3'
    -> Tokens: ['lshf', 'r0', 'r0', '#3']
  [Line   6] Address 0x3008: lshf ['r0', 'r0', '#3']
    -> Parse register: r0 -> R0
    -> Parse register: r0 -> R0
    -> Parse constant (decimal): #3 -> 3 (0x0003)
    -> Shift encoding: op=1101, dr=R0, sr=R0, mode=00, amount=3 -> 0xD003
    -> Write: 0xD003 (binary: 1101000000000011)
  [Line   7] Tokenize: '     rshfa r0,r0,#3'
    -> Tokens: ['rshfa', 'r0', 'r0', '#3']
  [Line   7] Address 0x300A: rshfa ['r0', 'r0', '#3']
    -> Parse register: r0 -> R0
    -> Parse register: r0 -> R0
    -> Parse constant (decimal): #3 -> 3 (0x0003)
    -> Shift encoding: op=1101, dr=R0, sr=R0, mode=11, amount=3 -> 0xD033
    -> Write: 0xD033 (binary: 1101000000110011)
  [Line   8] Tokenize: '     halt'
    -> Tokens: ['halt']
  [Line   8] Address 0x300C: halt []
    -> HALT encoding: -> 0xF025
    -> Write: 0xF025 (binary: 1111000000100101)
  [Line  10] Tokenize: 'a   .fill x1234'
    -> Tokens: ['a', '.fill', 'x1234']
  [Line  10] Address 0x300E: .fill ['x1234']
    -> Parse constant (hex): x1234 -> 4660 (0x1234)
    -> .FILL encoding: 0x1234
    -> Write: 0x1234 (binary: 0001001000110100)
  [Line  12] Tokenize: '    .end'
    -> Tokens: ['.end']
  [Line  12] .END: Stopping assembly

============================================================
Assembly complete: program/test_shf.asm -> results/test_shf.obj
Debug log saved to: /Users/wonjoonyun/Library/CloudStorage/OneDrive-TheUniversityofTexasatAustin/01_lecture/Computer_Architecture_Example/1_Opcode/debug/test_shf.asm.debug
============================================================

